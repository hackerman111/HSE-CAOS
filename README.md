Конспект написан при помощи gemini 2.5 pro (начиная с 10 лекции с помощью gemini 3 pro) на основе транскрипций лекций. 


---
На данный момент в конспекте  присутствуют все лекции кроме 12.

---

# Оглавление курса: Архитектура компьютера и ОС

## 1. Лекция 1: Введение в ОС и системные вызовы
*   **1.1 Введение и организационные моменты**
    *   1.1.1 Формула оценки
    *   1.1.2 Работа с домашними заданиями
*   **1.2 Зачем нужна операционная система?**
    *   1.2.1 Проблема прямого доступа к оборудованию
    *   1.2.2 Решение: операционная система как абстракция
*   **1.3 Работа с памятью в C++: краткое повторение**
    *   1.3.1 Линейно адресуемая память и указатели
    *   1.3.2 Динамическая память
    *   1.3.3 Разделение аллокации и конструирования
    *   1.3.4 Арифметика указателей
*   **1.4 Взаимодействие с ОС: системные вызовы**
    *   1.4.1 Системный вызов `read`
    *   1.4.2 Системный вызов `write`
    *   1.4.3 Обработка ошибок и частичных операций
*   **1.5 Работа с файлами**
    *   1.5.1 Системные вызовы `open` и `close`
    *   1.5.2 Пример чтения из файла

## 2. Лекция 2: Файловые системы и дескрипторы
*   **2.1 Взаимодействие с носителями информации**
    *   2.1.1 Почему не работать с диском напрямую?
*   **2.2 Права доступа в Linux**
    *   2.2.1 Чтение вывода `ls -l`
    *   2.2.2 Пользователь, группа и остальные
    *   2.2.3 Команда `chmod`
*   **2.3 Файловые дескрипторы и системные вызовы**
    *   2.3.1 Системный вызов `open`
    *   2.3.2 Структура открытого файла в ядре
    *   2.3.3 Другие важные системные вызовы (`lseek`, `dup`, `pipe`)
*   **2.4 Практика: Перенаправление ввода-вывода**
*   **2.5 Работа с директориями**

## 3. Лекция 3: Виртуальная память
*   **3.1 Дополнительные инструменты для работы с файловой системой**
    *   3.1.1 Новые флаги для системного вызова `open`
    *   3.1.2 Получение метаданных о файлах: семейство `stat`
*   **3.2 Управление памятью: виртуальная адресация**
    *   3.2.1 Проблема модели линейной памяти
    *   3.2.2 Виртуальная и физическая память
    *   3.2.3 Страничная организация памяти
*   **3.3 Системные вызовы для управления памятью: mmap**
    *   3.3.1 Аргументы и флаги `mmap`
    *   3.3.2 Примеры использования `mmap`
    *   3.3.3 Освобождение памяти: `munmap`
*   **3.4 Аргументы командной строки и переменные окружения**
    *   3.4.1 Аргументы командной строки
    *   3.4.2 Переменные окружения

## 4. Лекция 4: Углублённая работа с памятью и процессами
*   **4.1 Углублённая работа с памятью**
    *   4.1.1 Механизм Page Fault и ленивое выделение памяти
    *   4.1.2 Структура таблиц страниц (Page Tables)
    *   4.1.3 Дополнительные системные вызовы для работы с памятью
    *   4.1.4 Swap (своп) и его проблемы
*   **4.2 Управление процессами**
    *   4.2.1 Подмена процесса: семейство `exec`
    *   4.2.2 Создание процесса: `fork`
    *   4.2.3 Жизненный цикл процесса
    *   4.2.4 Паттерн `fork-exec`
*   **4.3 Межпроцессное взаимодействие: Pipelines**

## 5. Лекция 5: Сигналы и представление данных
*   **5.1 Управление процессами: группы и сигналы**
    *   5.1.1 Группы процессов (Process Groups)
    *   5.1.2 Сигналы (Signals)
    *   5.1.3 Отправка сигналов и ожидание процессов
    *   5.1.4 Управление памятью при `fork()` (COW)
*   **5.2 Представление данных**
    *   5.2.1 Текстовые и бинарные форматы
    *   5.2.2 Кодировки текста: от ASCII до Unicode
    *   5.2.3 Unicode и его кодировки
    *   5.2.4 Работа с Unicode в C/C++

## 6. Лекция 6: Ассемблер и низкоуровневое представление
*   **6.1 Представление целых чисел**
    *   6.1.1 Беззнаковые числа
    *   6.1.2 Знаковые числа: Прямой код (Sign-Magnitude)
    *   6.1.3 Знаковые числа: Дополняющий код (Two’s Complement)
*   **6.2 Выравнивание данных в памяти**
    *   6.2.1 Зачем нужно выравнивание?
*   **6.3 Процесс сборки программы**
    *   6.3.1 Препроцессор и `#include`
    *   6.3.2 Единицы трансляции и ускорение сборки
    *   6.3.3 Объектные файлы и символы
    *   6.3.4 Линковка и релокации
    *   6.3.5 Формат ELF
*   **6.4 Особенности C++: Имена и переменные**
    *   6.4.1 Искажение имён (Name Mangling)
    *   6.4.2 `Extern C`
    *   6.4.3 Глобальные переменные: `extern` против `static`
*   **6.5 Основы ассемблера и архитектуры**
    *   6.5.1 Архитектура фон Неймана
    *   6.5.2 Регистры и память
    *   6.5.3 Стек и вызовы функций
    *   6.5.4 Соглашение о вызовах (ABI)
*   **6.6 Практика: написание функций на ассемблере**
    *   6.6.1 - 6.6.5 Примеры (Возврат константы, Identity, Сложение, Условный переход, Цикл)

## 7. Лекция 7: Продвинутый ассемблер
*   **7.1 Адресация памяти в x86-64**
    *   7.1.1 Синтаксис Scale-Index-Base (SIB)
    *   7.1.2 Указание размера операнда
*   **7.2 Инструкция LEA (Load Effective Address)**
    *   7.2.1 LEA как оптимизация компилятора
*   **7.3 Работа со стеком и локальными переменными**
    *   7.3.1 Проблема: Callee-clobbered регистры
    *   7.3.2 Решение 1: Сохранение на стеке
    *   7.3.3 Решение 2: Callee-saved регистры
*   **7.4 Фреймовые указатели (Frame Pointers)**
    *   7.4.1 Структура стека с RBP
*   **7.5 Секции данных в ассемблере**
    *   7.5.1 Директивы ассемблера для данных
*   **7.6 Флаги процессора и условные переходы**
*   **7.7 Взаимодействие ассемблера и C/C++**
    *   7.7.1 Позиционно-независимый код (PIC) и RIP-адресация
    *   7.7.2 Оптимизация хвостового вызова (TCO)
    *   7.7.3 Вызов функций C (scanf / printf)
*   **7.8 Синтаксисы ассемблера: Intel vs. AT&T**

## 8. Лекция 8: Оптимизация и взаимодействие с ядром
*   **8.1 Оптимизация ассемблерного кода**
    *   8.1.1 Проблема раздельной компиляции
    *   8.1.2 Встроенный ассемблер (GNU Inline Assembly)
    *   8.1.3 Оптимизация на этапе компоновки (LTO)
*   **8.2 Взаимодействие с ядром и побочные эффекты**
    *   8.2.1 Прямой вызов `syscall`
    *   8.2.2 `volatile` и побочные эффекты
    *   8.2.3 Использование `asm` для барьеров компиляции
*   **8.3 Указатели, функции и полиморфизм**
    *   8.3.1 Указатели на функции и косвенные переходы
    *   8.3.2 Защита от атак: `endbr64`
    *   8.3.3 Реализация виртуальных функций C++
    *   8.3.4 JIT-компиляция (Just-in-Time)
*   **8.4 Динамическая компоновка**
    *   8.4.1 Мотивация и основы (.so)
    *   8.4.2 Механизмы PLT и GOT
    *   8.4.3 Перехват вызовов (`LD_PRELOAD`)
    *   8.4.4 Ручная загрузка библиотек (`dlopen`)
*   **8.5 Freestanding: Программы без stdlib**
    *   8.5.1 hosted vs freestanding
    *   8.5.2 Точка входа `_start`
    *   8.5.3 Загрузка и расширение знака
*   **8.6 Введение в архитектуру процессора**
    *   8.6.1 Проблема доступа к памяти и кэши
    *   8.6.2 Конвейер инструкций (Pipeline)

## 9. Лекция 9: Оптимизации CPU и дробные числа
*   **9.1 Оптимизации в современных процессорах**
    *   9.1.1 Ассоциативность кэша и её влияние на производительность
    *   9.1.2 Конвейерное и внеочередное исполнение
    *   9.1.3 Спекулятивное исполнение и уязвимости
    *   9.1.4 Предсказание ветвлений (Branch Prediction)
*   **9.2 Представление нецелых чисел**
    *   9.2.1 Числа с фиксированной точкой (Fixed-Point)
    *   9.2.2 Стандарт IEEE 754: числа с плавающей запятой
    *   9.2.3 Специальные случаи
    *   9.2.4 Погрешности и работа в C++
*   **9.3 Основы многопоточности**
    *   9.3.1 Процессы и потоки
    *   9.3.2 Синхронизация и доступ к общей памяти
    *   9.3.3 Атомарные операции (`std::atomic`)
    *   9.3.4 Примитивы блокирующей синхронизации
*   **9.4 Классическая проблема: обедающие философы**
    *   9.4.1 Постановка задачи
    *   9.4.2 Взаимоблокировка (Deadlock)

## 10. Лекция 10: Многопоточность и синхронизация
*   **10.1 Введение: Сигналы и наблюдаемый параллелизм**
    *   10.1.1 Наблюдаемый параллелизм и квантование
*   **10.2 Аппаратная поддержка многопоточности**
    *   10.2.1 Hyper-threading
    *   10.2.2 Привязка к ядрам (CPU Affinity)
    *   10.2.3 Закон Амдала
*   **10.3 Thread Safety (Потокобезопасность)**
    *   10.3.1 Контракты стандартной библиотеки C++
    *   10.3.2 Свободные функции
*   **10.4 Примитивы синхронизации**
    *   10.4.1 Семафор (Semaphore)
    *   10.4.2 RWLock (Read-Write Lock)
    *   10.4.3 Барьер (Barrier)
*   **10.5 Thread Local Storage (TLS)**
*   **10.6 Shared Pointer и безопасность**
*   **10.7 Атомики и модель памяти**
    *   10.7.1 Compare-And-Swap (CAS)
*   **10.8 Кэши и когерентность**
    *   10.8.1 Иерархия памяти и протокол MESI
    *   10.8.2 False Sharing (Ложное разделение)
*   **10.9 Процессы и Fork в многопоточной среде**
*   **10.10 Futex (Fast Userspace Mutex)**

## 11. Лекция 11: Введение в компьютерные сети
*   **11.1 Введение**
*   **11.2 Физический и Канальный уровни**
    *   11.2.1 Принципы передачи сигнала
    *   11.2.2 Протокол Ethernet и MAC-адресация
*   **11.3 Сетевой уровень (Network Layer)**
    *   11.3.1 Протокол IP и маршрутизация
    *   11.3.2 Подсети и маски (CIDR)
*   **11.4 Транспортный уровень (Transport Layer)**
    *   11.4.1 Сравнение TCP и UDP
    *   11.4.2 Порядок байт (Endianness)
*   **11.5 Прикладной уровень (Application Layer)**
    *   11.5.1 HTTP и DNS
*   **11.6 Socket API и Модели конкурентности**
    *   11.6.1 Базовый жизненный цикл TCP-сервера
    *   11.6.2 Эволюция моделей ввода-вывода (Thread-per-connection, Non-blocking, epoll)
*   **11.7 Итоги раздела**

## Глоссарий
## Словарь терминов
