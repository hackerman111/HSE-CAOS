\clearpage

\section{Управление процессами: группы и сигналы}

Продолжая изучение процессов как единиц параллелизма с изолированными адресными пространствами, мы рассмотрим механизмы их организации и взаимодействия. Для эффективного управления множеством связанных процессов операционные системы, включая Linux, предоставляют инструменты для их группировки и асинхронного уведомления.

\subsection{Группы процессов (Process Groups)}

Для упрощения управления несколькими процессами одновременно они могут быть объединены в группы. Каждый процесс в системе принадлежит определённой группе.

\begin{definitionbox}{Группа процессов}
\gls{pgid} — это числовой идентификатор, общий для нескольких процессов. Он позволяет применять операции, такие как отправка сигналов, ко всей группе сразу, а не к каждому процессу по отдельности. Каждый процесс также принадлежит \gls{sid}, которая объединяет группы процессов.
\end{definitionbox}

Для работы с \gls{pgid} существуют системные вызовы:
\begin{itemize}
    \item \texttt{getpgid(pid\_t pid)}: получает \gls{pgid} процесса с указанным \texttt{pid}. Вызов \texttt{getpgid(0)} вернёт \gls{pgid} текущего процесса.
    \item \texttt{setpgid(pid\_t pid, pid\_t pgid)}: устанавливает \gls{pgid} для процесса. Чтобы создать новую группу, обычно процесс вызывает \texttt{setpgid(0, 0)}, что создаёт новую группу с \gls{pgid}, равным \texttt{PID} этого процесса.
\end{itemize}

\subsection{Сигналы (Signals)}

\begin{definitionbox}{Сигнал}
\gls{signal} — это простой механизм \gls{ipc}, представляющий собой асинхронное уведомление, которое может быть отправлено процессу операционной системой или другим процессом. В отличие от пайпов, для отправки сигнала не требуется наличие родственной связи между процессами.
\end{definitionbox}

Сигналы, как и \texttt{PID}, являются просто числами. При получении сигнала процесс может отреагировать одним из нескольких способов:
\begin{itemize}
    \item \textbf{Term (Termination):} Завершение процесса. Это действие по умолчанию для большинства сигналов.
    \item \textbf{Ign (Ignore):} Игнорирование сигнала.
    \item \textbf{Core:} Завершение процесса с генерацией \gls{coredump}. Это файл, содержащий полный снимок адресного пространства процесса в момент сбоя, что позволяет проводить посмертную отладку (post-mortem debugging) с помощью таких инструментов, как GDB.
    \item \textbf{Stop:} Приостановка выполнения процесса.
    \item \textbf{Cont (Continue):} Возобновление выполнения приостановленного процесса.
\end{itemize}

Процесс может переопределить стандартную реакцию на большинство сигналов, установив собственный обработчик.

\begin{table}[h]
  \centering
  \caption{Некоторые распространённые сигналы и их действия по умолчанию}
  \label{tab:signals}
  \begin{tabularx}{\textwidth}{@{}lXlX@{}}
    \toprule
    Сигнал & Номер & Действие & Комментарий \\
    \midrule
    \texttt{SIGINT}  & 2  & Term & Отправляется при нажатии \texttt{Ctrl+C} в терминале. \\
    \texttt{SIGQUIT} & 3  & Core & Отправляется при нажатии \texttt{Ctrl+\textbackslash}. \\
    \texttt{SIGKILL} & 9  & Term & Гарантированно завершает процесс. Этот сигнал нельзя перехватить или проигнорировать. \\
    \texttt{SIGSEGV} & 11 & Core & Segmentation Fault. Отправляется при попытке доступа к неразрешённой области памяти. \\
    \texttt{SIGTSTP} & 20 & Stop & Отправляется при нажатии \texttt{Ctrl+Z} в терминале, приостанавливая процесс. \\
    \bottomrule
  \end{tabularx}
\end{table}

\subsection{Отправка сигналов и ожидание процессов}

Для отправки сигналов используется системный вызов \texttt{kill}. Несмотря на название, он может отправлять любой сигнал, а не только те, что завершают процесс.

\begin{lstlisting}[language=C, caption={Сигнатура системного вызова \texttt{kill}}, label={lst:kill}]
#include <signal.h>
int kill(pid_t pid, int sig);
\end{lstlisting}

Аргумент \texttt{pid} интерпретируется следующим образом:
\begin{itemize}
    \item \texttt{pid > 0}: Сигнал \texttt{sig} отправляется процессу с \texttt{PID}, равным \texttt{pid}.
    \item \texttt{pid < -1}: Сигнал отправляется всем процессам в группе с \gls{pgid}, равным \texttt{-pid}.
    \item \texttt{pid == 0}: Сигнал отправляется всем процессам в группе текущего процесса.
    \item \texttt{pid == -1}: Сигнал отправляется всем процессам, которым текущий пользователь имеет право отправлять сигналы (за исключением некоторых системных процессов).
\end{itemize}

Механизмы ожидания дочерних процессов, такие как \texttt{wait} и \texttt{waitpid}, позволяют не только дождаться завершения, но и получить информацию о причине.
\begin{itemize}
    \item \texttt{WIFEXITED(status)}: Возвращает \texttt{true}, если процесс завершился штатно через вызов \texttt{exit()}. Код возврата можно получить с помощью \texttt{WEXITSTATUS(status)}.
    \item \texttt{WIFSIGNALED(status)}: Возвращает \texttt{true}, если процесс был завершён сигналом. Номер сигнала можно получить через \texttt{WTERMSIG(status)}.
\end{itemize}

Вызов \texttt{waitpid} также интегрирован с группами процессов:
\begin{itemize}
    \item \texttt{waitpid(-1, ...)}: Ждёт любого дочернего процесса (стандартное поведение).
    \item \texttt{waitpid(-pgid, ...)}: Ждёт завершения любого дочернего процесса из группы с \gls{pgid}.
\end{itemize}

\subsection{Управление памятью при \texttt{fork()}}

Ранее мы говорили, что \texttt{fork()} создаёт полную копию адресного пространства родителя для дочернего процесса. Для современных процессов, занимающих гигабайты памяти, полное копирование было бы крайне неэффективным.

\begin{definitionbox}{Copy-on-Write (COW)}
\gls{cow} — это оптимизация, применяемая при вызове \texttt{fork()}. Вместо реального копирования всех страниц памяти, операционная система создаёт для дочернего процесса новые таблицы страниц, которые указывают на те же физические страницы, что и у родителя. Все эти страницы помечаются как доступные только для чтения.
При попытке записи в такую страницу (и родителем, и ребёнком) происходит аппаратное прерывание. ОС перехватывает его, создаёт реальную копию только этой конкретной страницы, и уже в неё производится запись. Это позволяет копировать только те данные, которые действительно изменяются, экономя время и память.
\end{definitionbox}

\subsubsection{Общая память через \texttt{mmap}}

Хотя \gls{cow} обеспечивает изоляцию, иногда процессам нужна общая область памяти для эффективного взаимодействия. Этого можно достичь с помощью системного вызова \texttt{mmap} с флагом \texttt{MAP\_SHARED}.

\begin{notebox}
Если участок памяти был создан с флагом \texttt{MAP\_PRIVATE}, то при \texttt{fork()} к нему применяется \gls{cow}. Если же был использован флаг \texttt{MAP\_SHARED}, то этот участок памяти будет общим для родителя и ребёнка после \texttt{fork()}: изменения, сделанные одним процессом, будут видны другому.
\end{notebox}

Важно помнить, что при работе с общей памятью возникает проблема синхронизации. Нет гарантий относительно порядка выполнения инструкций в родителе и ребёнке. Чтобы корректно читать данные, записанные другим процессом, необходимо использовать механизмы синхронизации, например, пайпы или сигналы, чтобы уведомить читающий процесс о готовности данных.

\begin{summarybox}
\begin{itemize}
    \item \textbf{Группы процессов} (\gls{pgid}) упрощают управление множеством процессов, позволяя применять операции ко всей группе сразу.
    \item \textbf{Сигналы} — это механизм асинхронных уведомлений для межпроцессного взаимодействия.
    \item Вызов \texttt{kill} позволяет отправлять сигналы процессам и группам процессов.
    \item \texttt{waitpid} может ожидать завершения процессов из определённой группы.
    \item \textbf{Copy-on-Write} (\gls{cow}) оптимизирует \texttt{fork()}, откладывая реальное копирование страниц памяти до первой операции записи.
    \item \texttt{mmap} с флагом \texttt{MAP\_SHARED} создаёт общую область памяти для родителя и дочерних процессов, но требует явной синхронизации доступа.
\end{itemize}
\end{summarybox}
\clearpage

\section{Представление данных}

Любые данные в компьютерных системах — будь то файлы, сетевые пакеты или потоки ввода-вывода — в конечном счёте представляются в виде последовательности байт. Способ преобразования структурированных данных в байты и обратно определяет формат данных.

\subsection{Текстовые и бинарные форматы}

Форматы данных условно делятся на две большие категории.

\begin{itemize}
    \item \textbf{Текстовые форматы} (JSON, YAML, XML, TXT) оптимизированы для чтения и редактирования человеком. Они, как правило, избыточны и требуют больше ресурсов для парсинга (синтаксического анализа).
    \item \textbf{Бинарные форматы} (исполняемые файлы ELF, архивы ZIP, форматы сериализации BSON, Protocol Buffers) оптимизированы для машинной обработки, компактности или скорости. Они нечитаемы для человека без специальных инструментов, но обрабатываются программами гораздо эффективнее.
\end{itemize}

Некоторые бинарные форматы, например, исполняемые файлы ELF (Executable and Linkable Format), спроектированы так, что их можно загрузить в память простым отображением файла с помощью \texttt{mmap}, без дополнительной обработки.

\subsubsection{Тонкости бинарных форматов: порядок байтов}

При работе с бинарными данными, содержащими числа размером более одного байта, возникает проблема \gls{endianness}.

\begin{definitionbox}{Порядок байтов (Endianness)}
\gls{endianness} определяет, как байты многобайтового числа располагаются в оперативной памяти.
\begin{itemize}
    \item \textbf{Little-endian}: Младший байт числа хранится по младшему адресу памяти. Этот порядок используется в большинстве современных архитектур, включая x86-64.
    \item \textbf{Big-endian}: Старший байт числа хранится по младшему адресу. Этот порядок часто используется в сетевых протоколах (network byte order).
\end{itemize}
\end{definitionbox}

Проблема возникает при передаче бинарных данных между системами с разным порядком байтов. Если данные записываются и читаются на одной и той же машине, беспокоиться о порядке байтов не нужно.

\begin{figure}[h!]
  \centering
  \begin{tikzpicture}[node distance=0.5cm and 1.5cm, font=\sffamily\small]
    % Заголовок
    \node[font=\bfseries] (title) at (3.5, 2.5) {32-битное число: \texttt{0x0A0B0C0D}};

    % Little-endian
    \node[box, minimum width=3cm, minimum height=0.8cm] (le_a0) {OD (младший)};
    \node[box, minimum width=3cm, minimum height=0.8cm, below=of le_a0] (le_a1) {0C};
    \node[box, minimum width=3cm, minimum height=0.8cm, below=of le_a1] (le_a2) {0B};
    \node[box, minimum width=3cm, minimum height=0.8cm, below=of le_a2] (le_a3) {0A (старший)};
    
    \node[left=0.2cm of le_a0, anchor=east] (addr_le0) {адрес \texttt{a}};
    \node[left=0.2cm of le_a1, anchor=east] (addr_le1) {\texttt{a+1}};
    \node[left=0.2cm of le_a2, anchor=east] (addr_le2) {\texttt{a+2}};
    \node[left=0.2cm of le_a3, anchor=east] (addr_le3) {\texttt{a+3}};
    
    \node[above=0.3cm of le_a0, font=\bfseries\color{AccentDark}] {Little-endian};

    % Big-endian
    \node[box, minimum width=3cm, minimum height=0.8cm, right=of le_a0] (be_a0) {0A (старший)};
    \node[box, minimum width=3cm, minimum height=0.8cm, below=of be_a0] (be_a1) {0B};
    \node[box, minimum width=3cm, minimum height=0.8cm, below=of be_a1] (be_a2) {0C};
    \node[box, minimum width=3cm, minimum height=0.8cm, below=of be_a2] (be_a3) {OD (младший)};
    
    \node[left=0.2cm of be_a0, anchor=east] (addr_be0) {адрес \texttt{a}};
    \node[left=0.2cm of be_a1, anchor=east] (addr_be1) {\texttt{a+1}};
    \node[left=0.2cm of be_a2, anchor=east] (addr_be2) {\texttt{a+2}};
    \node[left=0.2cm of be_a3, anchor=east] (addr_be3) {\texttt{a+3}};
    
    \node[above=0.3cm of be_a0, font=\bfseries\color{AccentDark}] {Big-endian};
  \end{tikzpicture}
  \caption{Расположение байтов числа \texttt{0x0A0B0C0D} в памяти при разном порядке байтов}
  \label{fig:endianness}
\end{figure}

\subsection{Кодировки текста: от ASCII до Unicode}

Представление текста — одна из фундаментальных задач. Исторически первой и наиболее влиятельной кодировкой стала \gls{ascii}.

\begin{definitionbox}{ASCII}
\gls{ascii} — стандарт, определяющий соответствие между числами (кодами от 0 до 127) и символами. Он использует только 7 бит, восьмой бит всегда равен нулю. ASCII включает в себя символы английского алфавита, цифры, знаки препинания и управляющие символы.
\end{definitionbox}

Среди управляющих символов ASCII есть:
\begin{itemize}
    \item \texttt{0x0A (\textbackslash{}n)} — перевод строки (Line Feed).
    \item \texttt{0x0D (\textbackslash{}r)} — возврат каретки (Carriage Return).
    \item \texttt{0x1B (ESC)} — Escape, используется для начала управляющих последовательностей, например, для управления цветом текста в терминале.
\end{itemize}

\begin{notebox}
Исторически сложилось два основных способа кодирования конца строки в текстовых файлах:
\begin{itemize}
    \item \textbf{Unix/Linux}: используется один символ \texttt{\textbackslash{}n}.
    \item \textbf{DOS/Windows}: используется последовательность из двух символов \texttt{\textbackslash{}r\textbackslash{}n} (возврат каретки и перевод строки).
\end{itemize}
Это различие может вызывать проблемы, например, при запуске скриптов с Windows-окончаниями строк в Linux, так как интерпретатор может неверно обработать \texttt{\textbackslash{}r} в конце строки shebang.
\end{notebox}

Очевидным недостатком \gls{ascii} является отсутствие поддержки символов других языков. Это привело к появлению множества несовместимых 8-битных кодировок (семейства ISO-8859, CP1251, KOI8-R и др.), которые использовали старший бит для кодирования национальных алфавитов. Проблема усугублялась в языках с иероглифической письменностью, где требовались многобайтовые кодировки со сложной логикой переключения режимов (например, EUC-JP).

\subsection{Unicode и его кодировки}

Для решения проблемы хаоса кодировок был создан стандарт \gls{unicode}.

\begin{definitionbox}{Unicode}
\gls{unicode} — это стандарт, который сопоставляет каждому символу из большинства мировых письменностей (включая мёртвые языки и эмодзи) уникальное целое число, называемое \textbf{\gls{unicode}}. Всего стандарт определяет более миллиона кодовых позиций (от \texttt{U+0000} до \texttt{U+10FFFF}).
\end{definitionbox}

Ключевые свойства Unicode:
\begin{itemize}
    \item Первые 128 кодовых позиций (\texttt{U+0000} -- \texttt{U+007F}) полностью совпадают с \gls{ascii}, обеспечивая частичную совместимость.
    \item Unicode сам по себе не является кодировкой. Он лишь определяет соответствие «символ $\leftrightarrow$ число». Для представления этих чисел в виде байтов используются специальные кодировки (encodings).
    \item Стандарт имеет свои сложности: один и тот же видимый символ (глиф) может быть представлен либо одним кодпоинтом, либо комбинацией из базового символа и модификующего знака (например, диакритики). Например, символ 'ё' можно представить как \texttt{U+0451} или как комбинацию 'е' (\texttt{U+0435}) и диерезиса (\texttt{U+0308}).
\end{itemize}

\subsubsection{Кодировка UTF-8}

Существует несколько способов кодирования кодпоинтов Unicode в байты: UCS-2, UCS-4, UTF-16. Наиболее популярным и де-факто стандартом в вебе и современных ОС стал \gls{utf8}.

\begin{definitionbox}{UTF-8}
\gls{utf8} — это кодировка Unicode с переменной длиной символа. Она кодирует кодпоинты в последовательности от 1 до 4 байт.
\end{definitionbox}

Основные преимущества UTF-8:
\begin{itemize}
    \item \textbf{Совместимость с ASCII:} Любой текст в кодировке ASCII является корректным текстом в UTF-8, так как кодпоинты до \texttt{U+007F} кодируются одним байтом, полностью совпадающим с их ASCII-представлением.
    \item \textbf{Эффективность:} Маленькие значения кодпоинтов кодируются меньшим числом байт. Это экономит место для текстов на латинице.
    \item \textbf{Надёжность:} Нулевой байт (\texttt{0x00}) используется только для кодирования нулевого кодпоинта (\texttt{U+0000}). Это позволяет использовать стандартные C-функции для работы со строками, оканчивающимися нулём.
    \item \textbf{Самосинхронизация:} По значению любого байта можно определить, является ли он началом символа или частью многобайтовой последовательности. Это позволяет легко находить границы символов в потоке байт.
\end{itemize}

Принцип кодирования в UTF-8 основан на использовании старших битов первого байта для указания общей длины последовательности (см. \cref{tab:utf8-encoding}).

\begin{table}[h!]
  \centering
  \caption{Схема кодирования символов в UTF-8}
  \label{tab:utf8-encoding}
  \begin{tabular}{@{}ccll@{}}
    \toprule
    Длина & Диапазон кодпоинтов & Схема байтов (x — биты кодпоинта) \\
    \midrule
    1 байт  & U+0000 – U+007F   & \texttt{0xxxxxxx} \\
    2 байта & U+0080 – U+07FF   & \texttt{110xxxxx 10xxxxxx} \\
    3 байта & U+0800 – U+FFFF   & \texttt{1110xxxx 10xxxxxx 10xxxxxx} \\
    4 байта & U+10000 – U+10FFFF & \texttt{11110xxx 10xxxxxx 10xxxxxx 10xxxxxx} \\
    \bottomrule
  \end{tabular}
\end{table}

\subsection{Работа с Unicode в C/C++}

Для поддержки Unicode в языках C и C++ существует тип \texttt{wchar\_t} («широкий символ»).

\begin{itemize}
    \item \texttt{wchar\_t}: Тип для хранения одного кодпоинта. Его размер зависит от платформы, но часто составляет 4 байта (32 бита), что достаточно для любого символа Unicode (аналогично кодировке UCS-4 в памяти).
    \item \texttt{L'a'}: Литерал типа \texttt{wchar\_t}.
    \item \texttt{L"строка"}: Широкий строковый литерал (массив \texttt{const wchar\_t}).
    \item Стандартная библиотека предоставляет аналоги для работы с широкими строками: \texttt{std::wstring}, \texttt{std::wcin}, \texttt{std::wcout} в C++ и функции \texttt{wprintf}, \texttt{wscanf} в C.
\end{itemize}

\subsubsection{Локали}

Чтобы стандартная библиотека знала, как преобразовывать широкие символы (\texttt{wchar\_t}) в байтовые последовательности (например, в UTF-8) при вводе-выводе, ей необходимо сообщить текущие региональные настройки.

\begin{definitionbox}{Локаль}
\gls{locale} — это набор параметров, описывающих языковые и культурные особенности пользователя. \gls{locale} определяет кодировку текста (\texttt{LC\_CTYPE}), формат чисел, валюты, даты и времени. Она обычно задаётся через переменные окружения, такие как \texttt{LANG} или \texttt{LC\_ALL}.
\end{definitionbox}

Перед началом работы с широким вводом-выводом в программе на C++ необходимо установить глобальную локаль, чтобы она была унаследована от настроек операционной системы.

\begin{lstlisting}[language=C++, caption={Установка локали для корректной работы с Unicode в C++}, label={lst:locale}]
#include <locale>
#include <iostream>
#include <string>

int main() {
    // Set the global locale based on the system's environment variables.
    // An empty string "" means "take from environment".
    std::locale::global(std::locale(""));

    // Now std::wcin and std::wcout will work correctly
    // with the encoding specified in the locale (e.g., UTF-8).
    std::wstring s;
    std::wcout << L"input text: ";
    std::wcin >> s;
    std::wcout << L"you input: " << s << L", len: " << s.size() << L" symb" << std::endl;
    
    return 0;
}
\end{lstlisting}

\begin{notebox}
Смешивать обычные потоки (\texttt{std::cout}) и широкие (\texttt{std::wcout}) в одной программе не рекомендуется. Такое смешивание может привести к непредсказуемому поведению и некорректному выводу, так как внутреннее состояние потоков может быть нарушено.
\end{notebox}

\begin{summarybox}
\begin{itemize}
    \item Данные могут быть представлены в \textbf{текстовом} (человекочитаемом) или \textbf{бинарном} (машиночитаемом) формате.
    \item При работе с бинарными данными важно учитывать \textbf{порядок байтов} (\gls{endianness}), особенно при передаче данных между разными системами.
    \item \textbf{ASCII} — исторически важная, но ограниченная 7-битная кодировка.
    \item \textbf{Unicode} является универсальным стандартом, присваивающим уникальный номер (\gls{unicode}) каждому символу.
    \item \textbf{UTF-8} — самая популярная кодировка для Unicode, эффективная и обратно совместимая с ASCII.
    \item В C/C++ для работы с Unicode используется тип \texttt{wchar\_t} и связанные с ним строковые классы и функции ввода-вывода.
    \item Для корректного ввода-вывода Unicode-текста необходимо настроить \textbf{локаль} программы, чтобы она соответствовала системным настройкам.
\end{itemize}
\end{summarybox}
